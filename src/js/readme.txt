/* ========================================= ПОЛЯ INPUT ========================================= */
Обозначение обязательных полей для заполнения:
    1) Нужно присвоить таким полям атрибут data-required (не самим input'ам, а тем полям, селекторы которых содержатся в inputsInittingSelectors)

Элементы управления input'ом (TextInput, TextInputCheckboxes): стрелка селекта, кнопка "Очистить поле":
    1) если у rootElem'а указан атрибут data-select-controls, будут созданы автоматически

Блоки с выбором региона/населенного пункта:
    1) для селектов и селектов с чекбоксами существуют классы TextInputRegions и TextInputCheckboxesRegion соответственно, для других компонентов по необходимости можно будет добавить новые классы на основе уже существующих;
    2) регионы содержатся в файле /json/regions.json, то есть при изменении там они будут подгружаться везде одинаково

Поля с чекбоксами в селекте:
    1) Чтобы не присваивать высчитанный max-height, а оставить max-height, указанный в css, нужно rootElem'у задать data-unset-max-height

Создание маски: data-input-mask="regExp", где
    1) regExp - регулярное выражение;
    2) символы в регулярном выражении обязательно выражаются точками;
    3) если в строке присутствуют пробелы, точки обязательно отделяются полностью от всех других символов. 
        Правильно: data-input-mask="\+7 \( ... \) ... - .. - ..", где "\( ... \)" 
        Неправильно: data-input-mask="\+7 \(...\) ... - .. - ..", где неправильно - "(\...\)"/.

Создание маски для проверки правильности заполнения поля: data-completion-mask="regExp", где
    1) regExp - регулярное выражение, составленное чисто по правилам регулярного выражения;
    2) поле не будет считаться заполненным, пока не будет input.value.match(regExp) == true.

Добавление нового поля через нажатие на кнопку: кнопка с атрибутом data-add-field, где в атрибут прописывается 3 аргумента, отделенных через ";":
    1) селектор или список селекторов: ".selector" или "{.selector-1, .selector-1, #selector-2}". Будет скопировано либо одно поле, либо несколько подряд, если передан список;
    2) количество возможных добавлений полей - число. По умолчанию - 1;
    3) селектор блока, после которого будет вставлено поле/поля. По умолчанию - будет вставлено после кнопки.
    Итоговый пример: data-add-field="{.selector-1, #selector-2}; 2; .selector-after", 
        где будут скопированы .selector-1 и #selector-2; они могут быть максимально вставлены два раза, т.е. итого 4 новых поля; вставлены они будут после блока .selector-after.

Добавление нового поля через выбор radio/checkbox: добавление к input'у атрибута data-addfield-input="value", где 
    1) добавляемым полям ставится атрибут data-addfield-input-target="value";
    2) полей можно добавлять несколько.

Список чекбоксов/радио кнопок (например, блок "Дополнительные сведения о желаемой работе"):
    1) Инициализируется классом page-input-buttons

Создание попапа по выбору определенного варианта чекбокса/селекта:
    1) input'у radio|checkbox задать атрибут data-create-popup="popupName, params";
    2) в классе CreatePopup в методе createPopup указать в switch case "popupName". Если уже есть, ничего делать более не нужно;
    3) если нужно перебросить какие-либо параметры, это делается в params, синтаксис которого: "key1:value1; key2:value2", т.е. где key - ключ параметра, а value - значение;
    4) один из общих параметров - initOnLoad:values, который открывает popup сразу при появлении, где values могут быть следующие:
        1) close - закроет popup сразу после появления (может быть полезно в связке с tags-list, когда нужно отобразить какие-либо теги по умолчанию);
        2) show - просто откроет popup сразу при появлении;
    5) в случае, если нужно настроить определенное поведение при выборе других радиокнопок, кроме того, который создает popup, нужно этим радиокнопкам задать атрибут data-popup-params="params", где у params синтаксис, описанный в 3), а все поведение задается в методе onOtherInputChange().

Создание тегов через селекты с чекбоксами:
    1) rootElem'у селекта нужно задать атрибут data-tags-select="key";
    2) создать блок-лист, которому задать атрибут data-tags-list="key";
    3) key должен совпадать, что свяжет одно с другим;
    4) когда в чекбоксе будет происходить событие change, он передаст выбранные значения в лист, а убранные удалит.