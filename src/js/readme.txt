/* ========================================= ПОЛЯ INPUT ========================================= */
Обозначение обязательных полей для заполнения:
    1) Нужно присвоить таким полям атрибут data-required (не самим input'ам, а тем полям, селекторы которых содержатся в inputsInittingSelectors)

Обычные селекты (с выбором одного варианта):
    1) Если нужно, чтобы вводились только числа, нужно указать атрибут data-numbers-only !ДЛЯ input!;
    2) rootELem'у можно передать в параметры data-params следующие значения:
        1) min:number - минимальное значение, доступное для ввода при data-numbers-only;
        2) max:number - максимальное значение, доступное для ввода при data-numbers-only.
    3) Если нужно, чтобы при выборе одного из вариантов появлялись какие-либо блоки/инпуты, нужно такому варианту задать атрибут data-select-create-input="selector". Будет найден ближайший элемент по селектору.
    4) Если нужно, чтобы высота открытого селекта была фиксированной, т.е. нужно задать свой max-height, для rootElem'а нужно задать атрибут data-unset-max-height

Селекты-чекбоксы:
    1) если нужно, чтобы в значении селекта были только значения чекбоксов (т.е. не допускается свободное написание строки), нужно добавить к rootElem'у атрибут data-required-check;
    2) если нужно, чтобы при выборе одного из вариантов было запрещено выбирать другие, нужно к такому варианту добавить атрибут data-oncheck-disable="index1, index2, ..., indexN", где index[1,2,N] == индексы запрещаемых вариантов;

Подсказки у селектов любого вида6
    1) по умолчанию подсказки остаются только те, которые имеют полное совпадение с введенной строкой. Чтобы оставлять и другие подсказки, нужно указать следующий атрибут со значением: data-params="showUnmatched:true"

Обычные чекбоксы (вне селекта):
    1) Если нужно, чтобы чекбоксы были связаны (т.е. при активации/деактивации одного происходило аналогичное действие с другим/другими), нужно основному задать атрибут data-checkboxes-bind="" со следующими аргументами:
        1) selectors:.selector1, selector2 - селекторы связываемых чекбоксов; 
        2) twoWays:true. Параметр может отсутствовать. Если есть, то связывает "крепко", т.е. все чекбоксы влияют друг на друга. Если отстутствует - только главный чекбокс с атрибутом data-checkbxes-bind влияет на другие;
        3) twoWaysOnBoundUncheck:true. Параметр может отсутствовать. Если есть, то при снятии check'а со СВЯЗАННОГО чекбокса будет деактивация основного чекбокса тоже.
    2) Пример: data-checkboxes-bind="selectors:selector1, selector2; twoWays:true".

Отображение в тексте строки "резюме" или "вакансия" в зависимости от выбранного типа объявления:
    1) выделить тегом <span></span> нужную строку в тексте;
    2) задать тегу атрибут data-status-dependable="applicant::резюме|/ employer::вакансия";
    3) applicant - название таба "объявление-резюме", employer - название таба "объявление-вакансия";
    4) вместо "резюме" и "вакансия" можно подставить и другие строки;
    5) возможно дополнительно указать data-status-dependable-attrs="attr1, attr2", где 
        1) attr1 и attr2 атрибуты, например, placeholder и value;
        2) если указываются атрибуты и нужно, чтобы также был изменен и сам текст, нужно указать innerHTML в этом dataset'е.

Отображение элемента в зависимости от выбранного типа объявления (вакансия/резюме):
    1) элементу присваивается тег data-status-dependable-display="value";
    2) value - applicant/emploeyer;
    3) данный болк повится, если значение атрибута совпадет со значением выбранного типа объявления.

Элементы управления input'ом (TextInput, TextInputCheckboxes): стрелка селекта, кнопка "Очистить поле":
    1) если у rootElem'а указан атрибут data-select-controls, будут созданы автоматически

Блоки с выбором региона/населенного пункта:
    1) для селектов простых и селектов с чекбоксами существуют классы TextInputRegions и TextInputCheckboxesRegion соответственно, для других компонентов по необходимости можно будет добавить новые классы на основе уже существующих;
    2) для поиска используется dadata api;
    3) можно указать, искать ли только города или только регионы (если и то и то, можно не указывать параметры):
        1) data-params="regionsOnly:true" - только регионы;
        2) data-params="citiesOnly:true" - только города


Поля с чекбоксами в селекте:
    1) Чтобы не присваивать высчитанный max-height, а оставить max-height, указанный в css, нужно rootElem'у задать data-unset-max-height

Создание маски: data-input-mask="regExp", где
    1) regExp - регулярное выражение;
    2) символы в регулярном выражении обязательно выражаются точками;
    3) если в строке присутствуют пробелы, точки обязательно отделяются полностью от всех других символов. 
        Правильно: data-input-mask="\+7 \( ... \) ... - .. - ..", где "\( ... \)" 
        Неправильно: data-input-mask="\+7 \(...\) ... - .. - ..", где неправильно - "(\...\)"/.

Создание маски для проверки правильности заполнения поля: data-completion-mask="regExp", где
    1) regExp - регулярное выражение, составленное чисто по правилам регулярного выражения;
    2) поле не будет считаться заполненным, пока не будет input.value.match(regExp) == true.

Добавление нового поля через нажатие на кнопку: кнопка с атрибутом data-add-field
    1) В атрибут прописываются аргументы, отделенные через ";":
        1) селектор или список селекторов: ".selector" или "{.selector-1, .selector-1, #selector-2}". Будет скопировано либо одно поле, либо несколько подряд, если передан список;
        2) количество возможных добавлений полей - число. По умолчанию - 1;
        3) селектор блока, после или до которого будет вставлено поле/поля. По умолчанию - будет вставлено после кнопки;
        4) нужно ли вставлять не после указанного, а перед указанным в 3) блоком (для "до" выставить "true", при любом другом значении будет вставлено "после")
        Итоговый пример: 
            data-add-field="{.selector-1, #selector-2}; 2; .selector-beforeafter; true", 
            где будут скопированы .selector-1 и #selector-2; они могут быть максимально вставлены два раза, т.е. итого 4 новых поля; вставлены они будут перед блоком .selector-beforeafter.
    2) Если нужно, чтобы блок или блоки, которые добавляются, изначально были скрыты, к ним добавляется атрибут data-addfield-hide. ВАЖНО! В таком случае НЕ допускать, чтобы сразу несколько кнопок ссылались на один блок, т.к. после иницализации от первой кнопки этот блок будет удален со страницы$
    3) В кнопку в атрибут data-params можно передать параметры:
        1) removeIconName:... - название иконки, пример: iconName:trash-can;
        2) showNumeration:true для отображения нумерации блоков;
        3) removeText:... - текст кнопки для удаления, по умолчанию "Удалить". Если нужно убрать текст - не передавать параметр;
        4) numerationBefore - текст, отображаемый до числа в нумерации;
        5) numerationAfter - текст, отображаемый после числа в нумерации;
        6) initialAmount:num - где num - число. Обозначает количество блоков, добавляемых при инциализации кнопки.

Управляемые из javascript добавляемые поля (data-add-"fieldname"-field)
    1) Являются тем же самым, что и data-add-field с теми же аргументами, кроме 1) (т.е. не указывается селектор-ссылка, с которого нужно брать верстку добавляемого блока);
    2) Верстка добавляемого блока зашита в js-коде. Инициализируется отдельным классом, наследующим от AddFieldButton.

Добавление нового поля через выбор radio/checkbox: добавление к input'у атрибута data-addfield-input="value", где 
    1) добавляемым полям ставится атрибут data-addfield-input-target="value";
    2) полей можно добавлять несколько.

Список чекбоксов/радио кнопок (например, блок "Дополнительные сведения о желаемой работе"):
    1) Инициализируется классом page-input-buttons
    2) Radio-кнопки обязательно должны находиться внутри контейнера page-input-buttons__item;
    3) Чтобы сделать обязательным выбор только одного из дочерних элементов page-input-buttons__list, нужно повесить на него атрибут data-required. Чтобы сделать обязательным выбор каждого элемента из дочерних (каждого page-input-buttons__item), нужно на эти элементы повесить data-required;
    4) Те элементы или списки, на которых нет data-required, считаются необязательными.

Создание попапа по выбору определенного варианта чекбокса/селекта:
    1) input'у radio|checkbox задать атрибут data-create-popup="popupName, params";
    2) в классе CreatePopup в методе createPopup указать в switch case "popupName". Если уже есть, ничего делать более не нужно;
    3) если нужно перебросить какие-либо параметры, это делается в params, синтаксис которого: "key1:value1; key2:value2", т.е. где key - ключ параметра, а value - значение;
    4) один из общих параметров - initOnLoad:values, который открывает popup сразу при появлении, где values могут быть следующие:
        1) close - закроет popup сразу после появления (может быть полезно в связке с tags-list, когда нужно отобразить какие-либо теги по умолчанию);
        2) show - просто откроет popup сразу при появлении;
    5) в случае, если нужно настроить определенное поведение при выборе других радиокнопок, кроме того, который создает popup, нужно этим радиокнопкам задать атрибут data-popup-params="params", где у params синтаксис, описанный в 3), а все поведение задается в методе onOtherInputChange().

Изменяемая цена у через блоки продвижения:
    1) блоку задается атрибут data-promotion-option="priceCurrent|priceOld", где
        1) priceCurrent - текущая цена (с учетом скидок и т.д.);
        2) priceOld - старая цена (до скидки или снижения).
    2) если внутри такого блока есть поле для управления количеством, в атрибут передается строка "changeable", например: data-promotion-option="50|100, changeable". Возможный вариант разметки приведен ниже
        <span class="flex">
            <span
                class="page-promotion__checkbox-amount-button page-promotion__amount-minus">-</span>
            <input class="page-promotion__amount-input" value="1" min="1" max="10"
                type="number">
            <span
                class="page-promotion__checkbox-amount-button page-promotion__amount-plus">+</span>
        </span>

Адаптив в блоке "Сделайте объявление более заметным":
    1) шапка с "Название услуги, ..." убирается;
    2) в каждом блоке, у которого есть элемент .promotion-more появляется кнопка, при нажатии на которую всплывает окно с информацией, которую отображает таблица.

Скрытие/показ блоков по состоянию checked у checkbox, radio:
    1) инпуту задается атрибут data-toggle-onchecked="show:selector, hide:selector", где
        1) одно из свойств можно пропустить, указав только "show:selector" или "hide:selector".
    2) по указанным селекторам найдутся ближайшие к текущему блоки;
    3) при состоянии checked===true, блок show будет показан, а hide будет скрыт;
    4) при состоянии checked===false происходят обратные пункту 3) действия;
    5) при надобности можно добавить в атрибут также свойства "inputShowValue:selectorOrString" и "inputHideValue:selectorOrString", где
        1) selectorOrString - выражен либо селектором (должен начинаться с ".", "#" или "["), либо строкой;
        2) если передан селектор, он должен вести на input с value, который и будет скопирован;
        3) если передана строка, она и будет по умолчанию вбита в ближайший input показанного блока.

Создание тегов через селекты с чекбоксами:
    1) rootElem'у селекта нужно задать атрибут data-tags-select="key";
    2) создать блок-лист, которому задать атрибут data-tags-list="key";
    3) key должен совпадать, что свяжет одно с другим;
    4) когда в чекбоксе будет происходить событие change, он передаст выбранные значения в лист, а убранные удалит.

Поля для создания дат:
    1) для указания ограничения по годам задать атрибут data-minmax-years="min:value ;max:value", где
        1) и для "min:" и для "max:" value можно указывать в формате "-2", "+2", "0", "1980";
        2) знак "+" или "-" перед числом значит, что допускаются года до значений, прибавленных или отнятых от текущего года на указанное число (текущий год: 2023, "+10" значит "до 2033");
        3) число "0" значит, что рамка - текущий год;
        4) четырехзначное число значит, что оно и является рамкой.
    2) для даты рождения по умолчанию значения data-minmax-year="min:-90; max:-14";
    3) если в один блок нужно поместить две даты рядом, блок должен иметь класс "dates-inputs", чтобы был единый блок для отображения ошибок (его нужно создать в разметке html)